--Historically
node H(X:bool) returns (Y:bool);
let
    Y = X -> (X and (pre Y));
tel

--Y since inclusive X
node SI(X,Y: bool) returns (Z:bool);
let
Z = Y and (X or (false -> pre Z));
tel

--Y since X
node S(X,Y: bool) returns (Z:bool);
let
Z = X or (Y and (false -> pre Z));
tel

--Once
node O(X:bool) returns (Y:bool);
let
 Y = X or (false -> pre Y);
tel

--Timed Once: less than or equal to N
node OTlore(const N: int; X: bool;) returns (Y: bool);
    var C:int;
let
    C = if X then 0
        else (-1 -> pre C + (if pre C <0 then 0 else 1));

    Y = 0 <= C and C <= N;
tel

--Timed Once: general case
node OT(const L: int; const R: int; X: bool;) returns (Y: bool);
var  D:bool;
let
  D=delay(X, R);
  Y=OTlore(L-R, D);
tel

-- Timed Historically: general case
node HT(const L: int; const R: int; X: bool;) returns (Y: bool);
let
  Y = not OT(L, R, not X);
tel

-- Timed Since: general case
node ST(const L: int; const R: int; X: bool; Y: bool;)  returns (Z: bool);
let
  Z = S(X, Y) and OT(L, R, X);
tel

-- Timed Since: general case
node SIT(const L: int; const R: int; X: bool; Y: bool;) returns (Z: bool);
let
  Z = SI(X, Y) and OT(L, R, X);
tel


node delay(X:bool; const R:int;) returns(Y:bool);
let

  Y = X;
 
tel

node abs(x:real)
returns(y:real);
let
	y = if x >= 0.0 then x else - x;
tel


    
(*@contract TriplexSignalMonitorSpec (Tlevel:real; ia:real; ib:real; ic:real; PCLimit: int;) returns (FC: int; set_val: real; PC: int);

let
var C1: bool = abs(ia-ib) > Tlevel;
var C2: bool = abs(ib-ic) > Tlevel;
var C3: bool = abs(ia-ic) > Tlevel;
var mid_value: real = if ((ia  <= ib and ib  <= ic) or (ic  <= ib and ib  <= ia))
                      then ib
                      else if ((ib <= ia and ia <= ic) or (ic <= ia and ia <= ib))
                      then ia
                      else ic;
var prePC: int = 0 -> pre PC;
var pre_set_val : real = (0.0 -> pre set_val);
var failure_in_progress : bool = miscompare  and prePC <= PCLimit and PC > 0;
var failure_must_be_latched : bool = miscompare  and prePC  > PCLimit;
var no_fail : bool = (FC =0);
var pre_no_fail : bool = (true  -> pre  no_fail);
var single_fail_reported : bool = (FC=1) or (FC=2) or (FC=4);
var miscompare: bool = (not C1 and C2 and C3)  or (C1 and not C2 and C3) or (C1 and C2 and not C3);


(* Req text: TriplexSignalMonitor shall always satisfy (single_fail_reported & failure_in_progress => set_val = pre_set_val)  *)
guarantee "TSM-004" (single_fail_reported and failure_in_progress) => set_val = pre_set_val;


(* Req text: TriplexSignalMonitor shall always satisfy ((pre_no_fail & failure_must_be_latched)=> single_fail_reported)  *)
guarantee "TSM-001" (pre_no_fail and failure_must_be_latched ) => single_fail_reported;


(* Req text: TriplexSignalMonitor shall always satisfy FC =2 =>  set_val = 0.5 * (ia +ic)  *)
guarantee "TSM-003b" FC = 2 => set_val = 0.5 * ( ia + ic );


(* Req text: TriplexSignalMonitor shall always satisfy FC =4 => set_val = 0.5 * (ib +ic)  *)
guarantee "TSM-003c" FC = 4 => set_val = 0.5 * ( ib + ic );


(* Req text: TriplexSignalMonitor  shall  always  satisfy  (no_fail => (set_val = mid_value))  *)
guarantee "TSM-002" no_fail => ( set_val = mid_value );


(* Req text: TriplexSignalMonitor shall always satisfy FC =1 => set_val = 0.5 * (ia +ib)  *)
guarantee "TSM-003a" FC = 1 => set_val = 0.5 * ( ia + ib );


tel
*)

